'''
Module to perform non-GUI functionality.
'''
# Built-in
import os
import time
from datetime import datetime
# PyQt5
from PyQt5 import QtCore
# pySerial
import serial
from serial.tools import list_ports
# Modules
from mutex_serial import MutexSerial
from crash_output_manager import CrashOutputManager
from popup_dialogs import PopupDialogs

#TODO: TEST EXCEPTION AS E WITH MANUAL RAISE -

class FunctionalityClass(QtCore.QObject):
    '''
    Class containing functions to perform non-GUI functionality.
    '''

    # Define signal objects as class attributes (required)
    fancy_unexpected_exception_signal = QtCore.pyqtSignal(str, str)
    finished = QtCore.pyqtSignal()
    update_status_callback = QtCore.pyqtSignal(str)


    # QThread .emit cannot be in static method
    def print_text(self, text):
        '''
        Uses a PyQt5 signal to print text to status widget in GUI.

        Parameters
        ----------
        self: Represents the instance of the Class
        text (string): User input text from Set Text text field in GUI

        Returns
        -------
        None
        '''
        self.update_status_callback.emit('<p style="font-size:11px; color:#DADADA;">' + f'{text}' + '</p>')


    # QThread .emit cannot be in static method
    def threading_table_handler(self, start_time, threading_table_text_list, threading_table_times_list):
        '''
        Loops through user-input values from GUI Threading Table. Sends text values to print_text method, then sleeps the associated specified time.

        Parameters
        ----------
        self: Represents the instance of the Class
        start_time (string): Str-type CPU Time generated in run.py
        threading_table_text_list (list): List of str-type user-input text from GUI Threading Table
        threading_table_times_list (list): List of str-type user-input time values from GUI Threading Table (seconds)

        Returns
        -------
        A Boolean value of True is returned if failure occurs at a known potential failure point.
        The Boolean value of True may be generated by a simple "return", or when the associated popup error dialog is exited.
        Returns "None", otherwise.
        '''
        self.update_status_callback.emit('<p style="font-size:11px; color:#DADADA;">' + '[Deploying threading table algorithms]<br>' + '</p>')

        # Send individual single value instructions to print_text method
        # Hold for associated sleep time
        # Repeat
        for i in range(len(threading_table_text_list)):
            self.print_text('<p style="font-size:11px; color:#DADADA;">' + f'--> Text to print: {threading_table_text_list[i]}' + '</p>')

            # Sleep + Print updates to GUI status box
            self.update_status_callback.emit('<p style="font-size:11px; color:#DADADA;">' + f'---> Holding for {threading_table_times_list[i]} seconds...' + '</p>')
            time.sleep(float(threading_table_times_list[i]))
            self.update_status_callback.emit('<p style="font-size:11px; color:#DADADA;">' + f'----> Complete ♪<br>' + '</p>')

        # Print this from here, prior to finished.emit(). If print in main thread, prints too early (immediately)
        self.update_status_callback.emit('<p style="font-size:11px; color:#DADADA;">' + f'<br>+++++++++++++++++<br>+++ TASK COMPLETE +++<br>+++++++++++++++++<br><br>Time taken: {datetime.now() - start_time}<br><br><br><br><br><br>' + '</p>')
        self.finished.emit()


    # QThread .emit cannot be in static method
    # Uses signals to call popups from within thread
    # Uses signals to update status from within thread
    def fancy_threading_table_handler(self, start_time, threading_table_text_list, threading_table_times_list):
        '''
        A wildly over-engineered printing function, to provide an example application of data management while threading and/or sleeping.
        Loops through user-input values from GUI Threading Table. 
        Uses a PyQt5 signal to print text to status widget in GUI, sleeps the associated specified time, then saves the printed text to an output .txt file.
        Does not utilize print_text method, or threading_table_handler method, which calls print_text method. Catches exceptions with distinct "fancy" variants of exception catches that may be in print_text method (none in this demonstrative application).
        Particular to the "fancy" variants is additional exception logging and data saving behavior.
        Saves crash data.
        Logs expected and unexpected exceptions.

        Parameters
        ----------
        self: Represents the instance of the Class
        start_time (string): Str-type CPU Time generated in run.py
        threading_table_text_list (list): List of str-type user-input text from GUI Threading Table
        threading_table_times_list (list): List of str-type user-input time values from GUI Threading Table (seconds)

        Returns
        -------
        A Boolean value of True is returned if failure occurs at a known potential failure point.
        The Boolean value of True may be generated by a simple "return", or when an associated popup error dialog is exited.
        Returns "None", otherwise.
        '''
        self.update_status_callback.emit('<p style="font-size:11px; color:#DADADA;">' + '[Deploying threading table algorithms]' + '</p>')

        # Declare output directory name
        # Declare output file name - including system time metadata
        # - System time metadata in output file name avoids overwrite concerns and relates crash exception log and crash data dump files
        # Declare output directory and file paths
        output_folder = 'Threading Table Text'
        output_file_name = f'threading_table_{datetime.now().strftime("YMD_%Y_%m_%d_HMS_%H_%M_%S")}_text.txt'
        output_folder_path = f'{os.path.dirname(os.getcwd())}\\{output_folder}'
        output_file_path = f'{output_folder_path}\\{output_file_name}'

        # Check for/make output directory
        if not os.path.isdir(f'{output_folder_path}'):
            os.mkdir(f'{output_folder_path}')

        # Treading cautiously, to catch exceptions. Outside nested with-open(s) and for-loop(s) so this can catch sudden breaks at any step
        step_counter = 0
        text_counter = 0
        text_list = []
        try:
            # Open output file
            # With more than one item, context managers are processed as if multiple with statements were nested - ORDER IS SIGNIFICANT
            # --> with open(file, 'w') also creates file if file does not exist
            with open(f'{output_file_path}', 'w') as text_file:  # with closes all after use

                self.update_status_callback.emit('<p style="font-size:11px; color:#FFFF00;">' + '[' + '<span style="color:#DADADA">' + 'Data saving mode engaged!' + '<span style="color:#FFFF00">' + ']<br>' + '</p>')

                text_file.write(
                    f'Input values taken from GUI Threading Table:\n'
                    f'Text: {threading_table_text_list}, Times: {threading_table_times_list}\n'
                    '\n'
                    'Data:\n'
                    'Step, Text, Time Held (s)\n'
                )

                for text, hold_time in zip(threading_table_text_list, threading_table_times_list):
                    self.update_status_callback.emit('<p style="font-size:11px; color:#DADADA;">' + f'--> Text to save: {text}' + '</p>')
                    # Sleep + print updates to GUI status widget
                    self.update_status_callback.emit('<p style="font-size:11px; color:#DADADA;">' + f'---> Holding for {hold_time} seconds...' + '</p>')
                    time.sleep(float(hold_time))
                    self.update_status_callback.emit('<p style="font-size:11px; color:#DADADA;">' + f'----> Complete ♪<br>' + '</p>')

                    # Append human-readable passive entry to primary list
                    text_list.append(f'{step_counter + 1}/{len(threading_table_text_list)}, {text}, {hold_time}\n')
                    text_counter += 1  # 1 text value saved
                    step_counter += 1

                    # <This for demonstrative purposes. applicable for significantly larger data sets>
                    # Dump data list after N steps, reset, dump the list, reset... - as a failsafe
                    # .writelines() auto goes through each entry in list. Is built-in version of for-loop .write(). Doesn't add newline, but here we have \n already
                    # Max of threading table row count steps, so dumping with every step does not significantly impact overall run time
                    # Power data retrieval occurs after hold time and prior to saving, so individual hold times are accurate and not impacted by application saving performance
                    if (text_counter == 1):
                        text_file.writelines(text_list)  # perform the dump
                        text_counter = 0
                        text_list = []

                # If above loop finishes prior to meeting text_counter == N test, dump leftovers in text_list. If data exists, it will not yet have been saved
                text_file.writelines(text_list)

        # Custom exception catchers that have extra functionality of logging the exception and output file management, in case user is away while fancy_threading_table_handler is running
        # Performing the logging FIRST, before crash data management, to maximize successful logging chances before anything else can throw more exceptions
        # Unexpected exception catcher
        # "except Exception:" >(better than) bare "except:" because won't catch KeyboardInterrupt, SystemExit, etc. - catching which could make it hard to exit script
        except Exception as e:

            # Manage the crash exception log file
            output_crash_log_file_path = CrashOutputManager.crash_log_manager(output_file_name)

            # Manage the crash data file
            output_crash_data_file_path = CrashOutputManager.crash_data_manager(output_file_name, output_file_path)

            # Append leftover data from the above loop to the new "CRASHDUMP" version of the output
            # If data exists, it will not yet have been saved. If list is empty, all retrieved data is already accounted for
            with open(output_crash_data_file_path, 'a') as text_file:
                if os.path.getsize(output_crash_data_file_path) == 0:
                    text_file.writelines('[Threading Table unexpected exception upon startup]\n[No data to collect]')
                else:
                    text_file.writelines(text_list)

            # Now that the exception logging and crash data dump is complete:
            # - Attempt to perform standard caught-exception update GUI status widget behavior
            # - Attempt to perform standard custom popup dialog error window GUI behavior for user-convenience
            self.update_status_callback.emit('<p style="font-size:11px; color:#D60000;">' + '<br>&lt;!&gt; ' + '<span style="color:#DADADA">' + 'An unexpected exception occurred. Please see: ' + '<span style="color:#727272">' + f'"{output_crash_log_file_path}"' + '<span style="color:#DADADA">' + ' and<br>' + '<span style="color:#727272">' + '{}'.format("\002"*43) + f'"{output_crash_data_file_path}"' + '</p>')  # using .format() as workaround to SyntaxError: f-string expression part cannot include a backslash - an alternative is to pass the string w/the backslash as a variable itself
            self.fancy_unexpected_exception_signal.emit(output_crash_log_file_path, output_crash_data_file_path)  # Blocks until dialog closed
            self.update_status_callback.emit('<p style="font-size:11px; color:#D60000;">' + '<br>Error encountered. Resetting application.<br><br><br><br><br><br>' + '</p>')
            return

        self.update_status_callback.emit('<p style="font-size:11px; color:#DADADA;">' + 'Output power list ' + '<span style="color:#727272">' + f'"{output_file_path}"' + '<span style="color:#337FE3">' + '  created ♪' + '</p>')

        # Print this from here, prior to finished.emit(). If print in main thread, prints too early (immediately)
        self.update_status_callback.emit('<p style="font-size:11px; color:#DADADA;">' + f'<br><br>+++++++++++++++++<br>+++ TASK COMPLETE +++<br>+++++++++++++++++<br><br>Time taken: {datetime.now() - start_time}<br><br><br><br><br><br>' + '</p>')
        self.finished.emit()


    def mutex_test(self):
        '''
        Demonstrative use of subclassing a library to reach context manager methods, to inject MUTEX functionality and make the associated class thread-safe.
        Target library: pySerial
        Subclassed class: serial.Serial

        Checks for serial ports. If found, opens the first returned. Passes.
        Prints updates to GUI status widget simulating order of MUTEX events.

        Parameters
        ----------
        self: Represents the instance of the Class

        Returns
        -------
        None
        '''
        # Check for serial ports
        ports = list_ports.comports()
        if not ports:  # Fails if empty list
            self.update_status_callback.emit('<p style="font-size:11px; color:#D60000;">' + '<br>&lt;!&gt; ' + '<span style="color:#DADADA">' + 'No serial ports detected. Unable to perform MUTEX demonstration.<br>' + '</p>')
            return

        # Visually simulating order of events through print statements - Events are happening, but prints not coming direct from mutex_serial.MutexSerial class (they are coming from here)
        self.update_status_callback.emit('<p style="font-size:11px; color:#DADADA;">' + f'MUTEX Demonstration<br>---------------------------<br><br>Subclassing pySerial to inject mutual exclusion lock into context manager...<br>Naming class "MutexSerial"...<br>MutexSerial will be unaccessible when in use, making it thread safe.<br>' + '</p>')
        try:
            with MutexSerial(port = ports[0].device) as ser:
                self.update_status_callback.emit('<p style="font-size:11px; color:#DADADA;">' + f'--> MutexSerial initiated' + '</p>')
                self.update_status_callback.emit('<p style="font-size:11px; color:#DADADA;">' + f'---> serial.Serial parent class inherited' + '</p>')
                self.update_status_callback.emit('<p style="font-size:11px; color:#DADADA;">' + f'----> MutexSerial locked' + '</p>')
                self.update_status_callback.emit('<p style="font-size:11px; color:#DADADA;">' + f'-----> Opened serial port "{ports[0].device}"' + '</p>')
                self.update_status_callback.emit('<p style="font-size:11px; color:#DADADA;">' + f'------> [Can perform protected actions here ✓]' + '</p>')

        except serial.serialutil.SerialException:
            self.update_status_callback.emit('<p style="font-size:11px; color:#D60000;">' + '<br>&lt;!&gt; ' + '<span style="color:#DADADA">' + 'Unexpected serial error encountered. Unable to perform MUTEX demonstration.<br>' + '</p>')
            return

        self.update_status_callback.emit('<p style="font-size:11px; color:#DADADA;">' + f'-----> Closed serial port "{ports[0].device}"' + '</p>')
        self.update_status_callback.emit('<p style="font-size:11px; color:#DADADA;">' + f'----> MutexSerial unlocked<br>' + '</p>')
        self.update_status_callback.emit('<p style="font-size:11px; color:#DADADA;">' + f'Complete<br><br>---------------------------<br><br>' + '</p>')

    # Does not use PyQt5 signal to call popup, as this is not run from a thread
    # Uses signal to update status because the signal already exists for another method in this class, and it also avoids passing update_status_callback as a parameter to avoid circular imports (which necessitates defining the method with it as a parameter - undesirable)
    def popup_demonstration(self, result):
        '''
        Demonstrates taking advantage of chaining PyQt5 events.
        Behavior based on "result" parameter.
        A False "result" will call a popup dialog, which blocks until closed.
        Waiting for and catching the dialog-exit-generated True bool, and passing it back through any number of modules via bool-check-returns
        (as is used after the line calling this method) allows for behavior to chain/cue and occur at any step along the chain/cue/from some specific module in the chain.
        Raises pop-up directly, via popup_dialogs.PopupDialogs.popup_demonstration(), and not with a PyQt5 signal since not being threaded.
        To use a signal would require the extra code of connecting the signal. Additionally, raising the pop-ups directly does not require passing their method objects as arguments.

        Parameters
        ----------
        self: Represents the instance of the Class
        result (bool): A bool passed with value dependant on user interaction with Pop-Up demonstration in GUI

        Returns
        -------
        None
        '''
        if result:
            self.update_status_callback.emit('<p style="font-size:11px; color:#DADADA;">' + f'Task succeeded!<br>' + '</p>')

        else:
            self.update_status_callback.emit('<p style="font-size:11px; color:#D60000;">' + '&lt;!&gt; ' + '<span style="color:#DADADA">' + 'Task failed!<br>' + '</p>')
            # Here we are directly calling the popup
            # In practice this could be some function that if a known exception is caught within, raises the popup, then returns the bool variable
            # If a variable is returned (and not being used for its intended purpose), AND is True - as generated from a closed pop-up dialog, then you know to print application failed, and "reset" the status log, etc.
            bool_var = PopupDialogs.popup_demonstration()  # Blocks until closed. Returns True
            # If True bool is returned, this is an example of what can br printed to status for "finality"
            self.update_status_callback.emit('<p style="font-size:11px; color:#D60000;">' + 'Error encountered. Resetting application.<br>' + '</p>')
            return bool_var
